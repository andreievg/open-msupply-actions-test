{
  "version": 3,
  "sources": ["../../../../utils.js", "../src/utils.js", "../src/convert_data.js"],
  "sourcesContent": ["const cleanUpNodes = (nodes) => {\n  let cleanNodes = [];\n  nodes.forEach((node) => {\n    if (Object.keys(node).length != 0) {\n      cleanNodes.push(cleanUpObject(node));\n    }\n  });\n  return cleanNodes;\n};\n\nconst cleanUpObject = (node) => {\n  let newNode = {};\n  // remove empty keys which will fail to parse\n  Object.keys(node).forEach(function (key) {\n    if (node[key] !== \"\" && node[key] !== undefined && node[key] !== null) {\n      if (typeof node[key] === \"object\") {\n        // recursively remove empty strings or undefined from graphql query\n        newNode[key] = cleanUpObject(node[key]);\n      } else {\n        newNode[key] = node[key];\n      }\n    }\n  });\n  return newNode;\n};\n\nconst getNestedValue = (node, key) => {\n  key = key + \"\";\n  return key.split(\".\").reduce((value, part) => value && value[part], node);\n};\n\nconst sortNodes = (nodes, sort, dir) => {\n  if (!!sort) {\n    nodes.sort((a, b) => {\n      const valueA = getNestedValue(a, sort);\n      const valueB = getNestedValue(b, sort);\n\n      if (valueA === valueB) {\n        return 0;\n      }\n\n      if (dir === \"asc\") {\n        return valueA > valueB ? 1 : -1;\n      } else {\n        return valueA < valueB ? 1 : -1;\n      }\n    });\n  }\n\n  return nodes;\n};\n\nmodule.exports = {\n  cleanUpObject,\n  cleanUpNodes,\n  getNestedValue,\n  sortNodes,\n};\n", "import { cleanUpNodes, sortNodes } from \"../../../../utils\";\n\nconst processStockLines = (nodes, sort, dir) => {\n  let cleanNodes = cleanUpNodes(nodes);\n  let sortedNodes = sortNodes(cleanNodes, sort, dir);\n  return sortedNodes;\n};\n\nmodule.exports = {\n  processStockLines,\n};\n", "import { processStockLines } from \"./utils\";\n\nfunction convert_data() {\n  const res = JSON.parse(Host.inputString());\n  res.data.stockLines.nodes = processStockLines(\n    res.data.stockLines.nodes,\n    // assign default sort values\n    res?.arguments?.sort ?? \"item.name\",\n    res?.arguments?.dir ?? \"desc\"\n  );\n  Host.outputString(JSON.stringify(res));\n}\n\nmodule.exports = {\n  convert_data,\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA,sBAAAA,UAAAC,SAAA;AAAA,QAAM,eAAe,CAAC,UAAU;AAC9B,UAAI,aAAa,CAAC;AAClB,YAAM,QAAQ,CAAC,SAAS;AACtB,YAAI,OAAO,KAAK,IAAI,EAAE,UAAU,GAAG;AACjC,qBAAW,KAAK,cAAc,IAAI,CAAC;AAAA,QACrC;AAAA,MACF,CAAC;AACD,aAAO;AAAA,IACT;AAEA,QAAM,gBAAgB,CAAC,SAAS;AAC9B,UAAI,UAAU,CAAC;AAEf,aAAO,KAAK,IAAI,EAAE,QAAQ,SAAU,KAAK;AACvC,YAAI,KAAK,GAAG,MAAM,MAAM,KAAK,GAAG,MAAM,UAAa,KAAK,GAAG,MAAM,MAAM;AACrE,cAAI,OAAO,KAAK,GAAG,MAAM,UAAU;AAEjC,oBAAQ,GAAG,IAAI,cAAc,KAAK,GAAG,CAAC;AAAA,UACxC,OAAO;AACL,oBAAQ,GAAG,IAAI,KAAK,GAAG;AAAA,UACzB;AAAA,QACF;AAAA,MACF,CAAC;AACD,aAAO;AAAA,IACT;AAEA,QAAM,iBAAiB,CAAC,MAAM,QAAQ;AACpC,YAAM,MAAM;AACZ,aAAO,IAAI,MAAM,GAAG,EAAE,OAAO,CAAC,OAAO,SAAS,SAAS,MAAM,IAAI,GAAG,IAAI;AAAA,IAC1E;AAEA,QAAM,YAAY,CAAC,OAAO,MAAM,QAAQ;AACtC,UAAI,CAAC,CAAC,MAAM;AACV,cAAM,KAAK,CAAC,GAAG,MAAM;AACnB,gBAAM,SAAS,eAAe,GAAG,IAAI;AACrC,gBAAM,SAAS,eAAe,GAAG,IAAI;AAErC,cAAI,WAAW,QAAQ;AACrB,mBAAO;AAAA,UACT;AAEA,cAAI,QAAQ,OAAO;AACjB,mBAAO,SAAS,SAAS,IAAI;AAAA,UAC/B,OAAO;AACL,mBAAO,SAAS,SAAS,IAAI;AAAA,UAC/B;AAAA,QACF,CAAC;AAAA,MACH;AAEA,aAAO;AAAA,IACT;AAEA,IAAAA,QAAO,UAAU;AAAA,MACf;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA;AAAA;;;ACzDA,IAAAC,iBAAA;AAAA,iBAAAC,UAAAC,SAAA;AAAA,QAAAC,gBAAwC;AAExC,QAAMC,qBAAoB,CAAC,OAAO,MAAM,QAAQ;AAC9C,UAAI,iBAAa,4BAAa,KAAK;AACnC,UAAI,kBAAc,yBAAU,YAAY,MAAM,GAAG;AACjD,aAAO;AAAA,IACT;AAEA,IAAAF,QAAO,UAAU;AAAA,MACf,mBAAAE;AAAA,IACF;AAAA;AAAA;;;ACVA,mBAAkC;AAElC,SAAS,eAAe;AACtB,QAAM,MAAM,KAAK,MAAM,KAAK,YAAY,CAAC;AACzC,MAAI,KAAK,WAAW,YAAQ;AAAA,IAC1B,IAAI,KAAK,WAAW;AAAA;AAAA,IAEpB,KAAK,WAAW,QAAQ;AAAA,IACxB,KAAK,WAAW,OAAO;AAAA,EACzB;AACA,OAAK,aAAa,KAAK,UAAU,GAAG,CAAC;AACvC;AAEA,OAAO,UAAU;AAAA,EACf;AACF;",
  "names": ["exports", "module", "require_utils", "exports", "module", "import_utils", "processStockLines"]
}
